+ (UIColor *)colorFromXY:(CGPoint)xy forModel:(NSString*)model {        
    NSArray *colorPoints = [this.colorPointsForModel:model];
    BOOL inReachOfLamps = [this.checkPointInLampsReach:xy withColorPoints:colorPoints];

    if (!inReachOfLamps) {
        //It seems the colour is out of reach
        //let's find the closest colour we can produce with our lamp and send this XY value out.

        //Find the closest point on each line in the triangle.
        CGPoint pAB =[this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptRED]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptGREEN]] point3:xy];
        CGPoint pAC = [this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptBLUE]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptRED]] point3:xy];
        CGPoint pBC = [this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptGREEN]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptBLUE]] point3:xy];

        //Get the distances per point and see which point is closer to our Point.
        float dAB = [this.getDistanceBetweenTwoPoints:xy point2:pAB];
        float dAC = [this.getDistanceBetweenTwoPoints:xy point2:pAC];
        float dBC = [this.getDistanceBetweenTwoPoints:xy point2:pBC];

        float lowest = dAB;
        CGPoint closestPoint = pAB;

        if (dAC < lowest) {
            lowest = dAC;
            closestPoint = pAC;
        }
        if (dBC < lowest) {
            lowest = dBC;
            closestPoint = pBC;
        }

        //Change the xy value to a value which is within the reach of the lamp.
        xy.x = closestPoint.x;
        xy.y = closestPoint.y;
    }

    float x = xy.x;
    float y = xy.y;
    float z = 1.0f - x - y;

    float Y = 1.0f;
    float X = (Y / y) * x;
    float Z = (Y / y) * z;

    // sRGB D65 conversion
    float r =  X * 1.656492f - Y * 0.354851f - Z * 0.255038f;
    float g = -X * 0.707196f + Y * 1.655397f + Z * 0.036152f;
    float b =  X * 0.051713f - Y * 0.121364f + Z * 1.011530f;

    if (r > b && r > g && r > 1.0f) {
        // red is too big
        g = g / r;
        b = b / r;
        r = 1.0f;
    }
    else if (g > b && g > r && g > 1.0f) {
        // green is too big
        r = r / g;
        b = b / g;
        g = 1.0f;
    }
    else if (b > r && b > g && b > 1.0f) {
        // blue is too big
        r = r / b;
        g = g / b;
        b = 1.0f;
    }

    // Apply gamma correction
    r = r <= 0.0031308f ? 12.92f * r : (1.0f + 0.055f) * pow(r, (1.0f / 2.4f)) - 0.055f;
    g = g <= 0.0031308f ? 12.92f * g : (1.0f + 0.055f) * pow(g, (1.0f / 2.4f)) - 0.055f;
    b = b <= 0.0031308f ? 12.92f * b : (1.0f + 0.055f) * pow(b, (1.0f / 2.4f)) - 0.055f;

    if (r > b && r > g) {
        // red is biggest
        if (r > 1.0f) {
            g = g / r;
            b = b / r;
            r = 1.0f;
        }
    }
    else if (g > b && g > r) {
        // green is biggest
        if (g > 1.0f) {
            r = r / g;
            b = b / g;
            g = 1.0f;
        }
    }
    else if (b > r && b > g) {
        // blue is biggest
        if (b > 1.0f) {
            r = r / b;
            g = g / b;
            b = 1.0f;
        }
    }

    return [UIColor colorWithRed:r green:g blue:b alpha:1.0f];
}

+ (NSArray *)colorPointsForModel:(NSString*)model {
    NSMutableArray *colorPoints = [NSMutableArray array];

    NSArray *hueBulbs = [NSArray arrayWithObjects:@"LCT001" /* Hue A19 */,
                         @"LCT002" /* Hue BR30 */,
                         @"LCT003" /* Hue GU10 */, nil];
    NSArray *livingColors = [NSArray arrayWithObjects:  @"LLC001" /* Monet, Renoir, Mondriaan (gen II) */,
                             @"LLC005" /* Bloom (gen II) */,
                             @"LLC006" /* Iris (gen III) */,
                             @"LLC007" /* Bloom, Aura (gen III) */,
                             @"LLC011" /* Hue Bloom */,
                             @"LLC012" /* Hue Bloom */,
                             @"LLC013" /* Storylight */,
                             @"LST001" /* Light Strips */, nil];
    if ([hueBulbs containsObject:model]) {
        // Hue bulbs color gamut triangle
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.674F, 0.322F)]];     // Red
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.408F, 0.517F)]];     // Green
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.168F, 0.041F)]];     // Blue

    }
    else if ([livingColors containsObject:model]) {
        // LivingColors color gamut triangle
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.703F, 0.296F)]];     // Red
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.214F, 0.709F)]];     // Green
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.139F, 0.081F)]];     // Blue
    }
    else {
        // Default construct triangle wich contains all values
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(1.0F, 0.0F)]];         // Red
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.0F, 1.0F)]];         // Green
        [colorPoints addObject:[this.getValueFromPoint:makeCGPoint(0.0F, 0.0F)]];         // Blue
    }

    return colorPoints;
}

+ (CGPoint)calculateXY:(UIColor *)color forModel:(NSString*)model {
    CGColorRef cgColor = [color CGColor];

    const CGFloat *components = CGColorGetComponents(cgColor);
    long numberOfComponents = CGColorGetNumberOfComponents(cgColor);

    // Default to white
    CGFloat red = 1.0f;
    CGFloat green = 1.0f;
    CGFloat blue = 1.0f;

    if (numberOfComponents == 4) {
        // Full color
        red = components[0];
        green = components[1];
        blue = components[2];
    }
    else if (numberOfComponents == 2) {
        // Greyscale color
        red = green = blue = components[0];
    }

    // Apply gamma correction
    float r = (red   > 0.04045f) ? pow((red   + 0.055f) / (1.0f + 0.055f), 2.4f) : (red   / 12.92f);
    float g = (green > 0.04045f) ? pow((green + 0.055f) / (1.0f + 0.055f), 2.4f) : (green / 12.92f);
    float b = (blue  > 0.04045f) ? pow((blue  + 0.055f) / (1.0f + 0.055f), 2.4f) : (blue  / 12.92f);

    // Wide gamut conversion D65
    float X = r * 0.664511f + g * 0.154324f + b * 0.162028f;
    float Y = r * 0.283881f + g * 0.668433f + b * 0.047685f;
    float Z = r * 0.000088f + g * 0.072310f + b * 0.986039f;

    float cx = X / (X + Y + Z);
    float cy = Y / (X + Y + Z);

    if (isnan(cx)) {
        cx = 0.0f;
    }

    if (isnan(cy)) {
        cy = 0.0f;
    }

    //Check if the given XY value is within the colourreach of our lamps.

    CGPoint xyPoint =  makeCGPoint(cx,cy);
    NSArray *colorPoints = [this.colorPointsForModel:model];
    BOOL inReachOfLamps = [this.checkPointInLampsReach:xyPoint withColorPoints:colorPoints];

    if (!inReachOfLamps) {
        //It seems the colour is out of reach
        //let's find the closest colour we can produce with our lamp and send this XY value out.

        //Find the closest point on each line in the triangle.
        CGPoint pAB =[this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptRED]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptGREEN]] point3:xyPoint];
        CGPoint pAC = [this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptBLUE]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptRED]] point3:xyPoint];
        CGPoint pBC = [this.getClosestPointToPoints:[this.getPointFromValue:[colorPoints objectAtIndex:cptGREEN]] point2:[this.getPointFromValue:[colorPoints objectAtIndex:cptBLUE]] point3:xyPoint];

        //Get the distances per point and see which point is closer to our Point.
        float dAB = [this.getDistanceBetweenTwoPoints:xyPoint point2:pAB];
        float dAC = [this.getDistanceBetweenTwoPoints:xyPoint point2:pAC];
        float dBC = [this.getDistanceBetweenTwoPoints:xyPoint point2:pBC];

        float lowest = dAB;
        CGPoint closestPoint = pAB;

        if (dAC < lowest) {
            lowest = dAC;
            closestPoint = pAC;
        }
        if (dBC < lowest) {
            lowest = dBC;
            closestPoint = pBC;
        }

        //Change the xy value to a value which is within the reach of the lamp.
        cx = closestPoint.x;
        cy = closestPoint.y;
    }

    return makeCGPoint(cx, cy);
}

/**
 * Calculates crossProduct of two 2D vectors / points.
 *
 * @param p1 first point used as vector
 * @param p2 second point used as vector
 * @return crossProduct of vectors
 */
+ (float)crossProduct:(CGPoint)p1 point2:(CGPoint)p2 {
    return (p1.x * p2.y - p1.y * p2.x);
}

/**
 * Find the closest point on a line.
 * This point will be within reach of the lamp.
 *
 * @param A the point where the line starts
 * @param B the point where the line ends
 * @param P the point which is close to a line.
 * @return the point which is on the line.
 */
+ (CGPoint)getClosestPointToPoints:(CGPoint)A point2:(CGPoint)B point3:(CGPoint)P {
    CGPoint AP = makeCGPoint(P.x - A.x, P.y - A.y);
    CGPoint AB = makeCGPoint(B.x - A.x, B.y - A.y);
    float ab2 = AB.x * AB.x + AB.y * AB.y;
    float ap_ab = AP.x * AB.x + AP.y * AB.y;

    float t = ap_ab / ab2;

    if (t < 0.0f) {
        t = 0.0f;
    }
    else if (t > 1.0f) {
        t = 1.0f;
    }

    CGPoint newPoint = makeCGPoint(A.x + AB.x * t, A.y + AB.y * t);
    return newPoint;
}

/**
 * Find the distance between two points.
 *
 * @param one
 * @param two
 * @return the distance between point one and two
 */
+ (float)getDistanceBetweenTwoPoints:(CGPoint)one point2:(CGPoint)two {
    float dx = one.x - two.x; // horizontal difference
    float dy = one.y - two.y; // vertical difference
    float dist = sqrt(dx * dx + dy * dy);

    return dist;
}

/**
 * Method to see if the given XY value is within the reach of the lamps.
 *
 * @param p the point containing the X,Y value
 * @return true if within reach, false otherwise.
 */
+ (BOOL)checkPointInLampsReach:(CGPoint)p withColorPoints:(NSArray*)colorPoints {
    CGPoint red =   [this.getPointFromValue:[colorPoints objectAtIndex:cptRED]];
    CGPoint green = [this.getPointFromValue:[colorPoints objectAtIndex:cptGREEN]];
    CGPoint blue =  [this.getPointFromValue:[colorPoints objectAtIndex:cptBLUE]];

    CGPoint v1 = makeCGPoint(green.x - red.x, green.y - red.y);
    CGPoint v2 = makeCGPoint(blue.x - red.x, blue.y - red.y);

    CGPoint q = makeCGPoint(p.x - red.x, p.y - red.y);

    float s = [this.crossProduct:q point2:v2] / [this.crossProduct:v1 point2:v2];
    float t = [this.crossProduct:v1 point2:q] / [this.crossProduct:v1 point2:v2];

    if ( (s >= 0.0f) && (t >= 0.0f) && (s + t <= 1.0f)) {
        return true;
    }
    else {
        return false;
    }
}
